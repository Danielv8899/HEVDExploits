#include "util.h"
#include <algorithm>
#include <iostream>


ULONGLONG util::getBaseAddr(LPCWSTR drvname)
{
    LPVOID drivers[1024];
    DWORD cbNeeded;
    int nDrivers, i = 0;

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
    {
        WCHAR szDrivers[1024];
        nDrivers = cbNeeded / sizeof(drivers[0]);
        for (i = 0; i < nDrivers; i++)
        {
            if (GetDeviceDriverBaseName(drivers[i], szDrivers, sizeof(szDrivers) / sizeof(szDrivers[0])))
            {
                if (wcscmp(szDrivers, drvname) == 0)
                {
                    return (ULONGLONG)drivers[i];
                }
            }
        }
    }
    return 0;
}

void util::GetGadgets(OPS ops, GADGETS gadgets) {
    HMODULE lpFileName = LoadLibrary(L"C:\\Users\\nigga\\Desktop\\ntoskrnl.exe");
    if (!lpFileName) {
        printf("error getting handle to ntoskrnl, error code: %x\n", GetLastError());
        exit(-1);
    }
    for (std::map<std::string, std::vector<BYTE>>::iterator iter = ops.begin(); iter != ops.end(); ++iter)
    {
        std::string k = iter->first;
        unsigned char* v = (unsigned char*)&iter->second[0];
        QWORD gadgetOffset = FindGadget(lpFileName, v, (SIZE_T)iter->second.size());
        if (gadgetOffset == -1) {
            printf("gadget lookup failed for %s\n", iter->first.c_str());
            printf("byte array searched: %02X %02X %02X %02X\n", v[0],v[1],v[2],v[3]);
            exit(-1);
        }
        gadgets[k] = gadgetOffset;
    }
}

QWORD util::FindGadget(HMODULE moduleName, BYTE* opCodeArray, UINT opCodeSize) {
    PBYTE buffer = (PBYTE)moduleName;
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)buffer;
    PIMAGE_NT_HEADERS ntHeader;
    buffer += dosHeader->e_lfanew;
    ntHeader = (PIMAGE_NT_HEADERS)buffer;
    IMAGE_OPTIONAL_HEADER opHeader;
    opHeader = ntHeader->OptionalHeader;

    BYTE* ntoskrnlBuf = NULL;
    ntoskrnlBuf = (BYTE*)malloc(opHeader.SizeOfCode);

    printf("lfanew: %d\t sizeofcode: %d\n", dosHeader->e_lfanew, opHeader.SizeOfCode);

    if (ntoskrnlBuf == NULL) {
        std::cout << "failed ntoskrnbuf malloc\n";
        exit(0);
    }
    SIZE_T sizeRead;
    if (!ReadProcessMemory(GetCurrentProcess(), moduleName, ntoskrnlBuf, opHeader.SizeOfCode, &sizeRead)) {
        printf("failed ReadProcessMemory, error code: %x\n", GetLastError());
        exit(-1);

    }

    BYTE* buf = ntoskrnlBuf;
    PBYTE bufLast = buf + opHeader.SizeOfCode;
    BYTE* pattern = opCodeArray;
    PBYTE patternLast = pattern + opCodeSize;
    // std::search would search from start, however at start more gadgets are non paged in the kernel
    PBYTE occurence = std::find_end(buf, bufLast, pattern, patternLast);// returns iterator to first occurence of sequence

    BOOL found = (occurence != bufLast);

    if (found)
    {
        printf("lookup success for %02X %02X %02X %02X\n", pattern[0], pattern[1], pattern[2], pattern[3]);
        printf("address: %08X\n",occurence - buf);
        return buf - occurence;
    }
    else
    {
        printf("lookup failed for %02X %02X %02X %02X\n", pattern[0], pattern[1], pattern[2], pattern[3]);
        printf("size = %d\n", opHeader.SizeOfCode);
        printf("pattern size = %d\n", opCodeSize);
        exit(-1);
        return -1;
    }
}

